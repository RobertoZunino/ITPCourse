import Mathlib.Data.Real.Basic
import Mathlib.Data.Complex.Basic
import Mathlib.Tactic.Ring
import Mathlib.Tactic.Linarith

section Basic_arithmetic
/-
  We start with some basic arithmetic formulas manipulations and tactics.

  The main numeric types are:
  - `Complex`, also written as `ℂ`
  - `Real`, also written as `ℝ`
  - `Rat`, also written as `ℚ`
  - `Int`, also written as `ℤ`
  - `Nat`, also written as `ℕ`

  Note that we need the related `import`s for the fancy notation.
-/

example: ℂ := 1 + Complex.I
example: ℝ := 4.6
example: ℚ := 12/17
example: ℤ := -42
example: ℕ := 12

/-
  A basic equation
-/
example: Complex.I^2 = -1
  := Complex.I_sq

/-
  The `ring` tactic can be used to prove those equations that follow by
  commutative ring laws, only.
-/
example (a b: ℝ)
  : (a + b)*(a - b) = a^2 - b^2
  := by ring

/-
  The `ring` tactic will not solve equations that depend on other laws.
  However, we can use `ring_nf` to "simplify" the formula with the ring
  laws, apply some other law, and then try `ring` again.
-/
example: (1 + Complex.I)^2 = 2 * Complex.I
  := by
  ring_nf
  rw [Complex.I_sq]
  ring

/-
  `ring` also applies to semi-rings like `ℕ`.
-/
example (a b: ℕ)
  : (a + b)^2 = a^2 + b^2 + 2*a*b
  := by
  ring

/-
  Linear inequalities can be solved with `linarith`.
  Hypotheses are used as needed.
-/
example (a: ℤ)
  : a < a + 1
  := by
  linarith

example (a b: ℤ)
  (h: a < b)
  : a < b + 1
  := by
  linarith

/-
  Non-linear inequalities can _not_ be solved with `linarith`, in general.
  Sometimes, they can anyway, since the solving process does not really
  involve dealing with the non-linear parts.
-/
example (a b: ℤ)
  : a*b < a*b + 1
  := by
  linarith

/-
  More complex inequalities can require more manual intervention:
-/
example (a b: ℝ)
  : |a+b| < |a|+|b|+1
  := by
  calc |a+b|
  _ ≤ |a| + |b| := abs_add_le _ _
  _ < |a| + |b| + 1 := by linarith

/-
  Sometimes, two large formulas only differ by a small part.
  The `congr` and `gcongr` tactics can effectively "remove" the common
  parts and focus only on the points the formulas differ.
  They generate a subgoal for each difference.
-/
example (a b c: ℝ)
  (h: a + 6 < b)
  : 1 + c + 5*(c + a + c) ≤ 1 + c + 5*(c + b + c)
  := by
  gcongr
  case bc.h.bc.bc =>
    linarith

/-
  The subgoal names generated by `congr`/`gcongr` can be ugly.
  We can use `.` instead of `case … =>` to avoid mentioning them.
-/
example (a b c: ℝ)
  (h: a + 6 < b)
  : 1 + c + 5*(c + a + c) ≤ 1 + c + 5*(c + b + c)
  := by
  gcongr
  . linarith

/-
  Sometimes, we want to rewrite a part of the formula in an equivalent
  form, so that we can apply a library theorem later on.
  This could be done using `have eq := … ; rw [eq]`, but it is inconvenient.
-/
example (x: ℝ) (P: ℝ → Prop)
  (h1: P (x+x))
  : P (2*x)
  := by
  have eq: 2*x = x+x := by ring
  rw [eq]
  exact h1
/-
  It is simpler to use `convert_to` instead.
-/
example (x: ℝ) (P: ℝ → Prop)
  (h1: P (x+x))
  : P (2*x)
  := by
  convert_to P (x+x)
  . ring   -- Subgoal: prove the equation for the required conversion
  -- We are back to the main statement
  exact h1

/-
  __Exercise__: Prove the following.
  You will likely only need basic tactics, and `simp` to simplify a few
  sums.
-/
theorem forall_x_y_h
  (P: Real → Real → Prop)
  : (∀ x y, P x y) ↔ (∀ x h, P x (x+h))
  := sorry

theorem forall_x_y_h_left
  (P: Real → Real → Prop)
  : (∀ x h, P x (x+h)) → (∀ x y, P x y)
  := (forall_x_y_h P).mpr

/-
  __Exercise__: Prove the following.
  You might want to use:
  - Tactics `linarith`, `let`, `unfold`, `constructor`
  - `lt_or_le`
-/
theorem forall_ε (a b: Real)
  : (a ≤ b) ↔ (∀ ε>0, a ≤ b + ε)
  := sorry

/-
  __Exercise__: Prove the following.
  Note how `n: Nat` is automatically converted to a `Real` below when we use
  `n * a`. This is done through the `NatCast` type class. If you see `↑n`
  printed instead of `n`, the `↑` is denoting the automatic coercion.
  You might want to use:
  - `⌈ … ⌉₊` aka `Nat.ceil`
  - `Nat.le_ceil`
  - `div_mul_cancel₀`
  - Tactic `push_cast` to turn `↑(a+b)` into `↑a + ↑b`
  - Tactics `ring`, `congr`, `gcongr`, `positivity`, `simp`, `calc`
-/
theorem archimedes (a b: Real)
  (h1: 0 < a)
  (h2: a ≤ b)
  : ∃ n: Nat, n * a > b
  := sorry

end Basic_arithmetic

section On_partial_operations
/-
  Note that some operations on numeric types are partial, i.e. they are
  undefined in some cases. Division by zero is the obvious example.
  Subtraction on naturals can also fail, e.g. `3 - 5`.

  When defining these operations, the library designers had a few options:
  - Require a proof as an additional argument.
    This would require using e.g., `Real.div x y proof_of_y≠0` at each use
    of division.
  - Return an optional result, using some sum type.
    Defining `Real.div: ℝ → ℝ → Option ℝ` allows to return `.none` when the
    second argument is zero, and `.some result` otherwise.
    This would make harder to write `5 + x/y` since `x/y` is an `Option ℝ`,
    and not a `ℝ`.
  - Define division in all cases, in some arbitrary way (say `0`).
    Letting `x/0 = 0` allows one to write formulas more easily, but then
    the user must be careful not to fall into this case.

  The lean designers opted for the last solution:
-/
example: (1: ℝ) / (0: ℝ) = (0: Real) := by ring  -- "Undefined" denoted as 0
example: (3: ℕ) - (5: ℕ) = (0: ℕ)    := by ring  -- "Undefined" denoted as 0
example: (21: ℕ) / (10: ℕ) = (2: ℕ)  := by ring  -- Quotient
/-
  This idea is widespread across the library: the designers opted for
  defining several partial operations in an arbitrary way, so to make them
  total (always defined).

  For instance, when doing calculus, the derivative of the absolute value
  `deriv (λ x => |x|)` is _always_ defined in Lean. More specifically, it is
  `-1` when `x<0`, `0` when `x=0` and `+1` when `x>0`.
  There is another predicate `HasDerivAt …` that states that a function is
  actually differentiable at a point, and that correctly does not hold at
  `0` for the absolute value function.

  Be wary! Properties like
    `(a - b) + b = a`
  fail on `ℕ`, without additional hypotheses. When a tactic unexpected
  fails, it could be because the statement is subtly wrong in some corner
  cases.
-/
end On_partial_operations

section Intervals
/-
  Real intervals in Lean are denoted as follows:
  - `Set.Ioo x y` open interval `(x,y)`
  - `Set.Icc x y` closed interval `[x,y]`
  - `Set.Ico x y` semi-open interval `[x,y)`
  - `Set.Ioc x y` semi-open interval `(x,y]`
  - `Set.Ioi x` open straight `(x,+∞)`
  - `Set.Iio x` open straight `(-∞,x)`
  - `Set.Ici x` closed straight `[x,+∞)`
  - `Set.Iic x` closed straight `(-∞,x]`
  - `Set.univ` the whole real line `(-∞,+∞)`
-/
example (x y: Real):
  Set.Ioi x ∩ Set.Iio y = Set.Ioo x y
  := rfl

/-
  __Exercise__: Prove the following.
-/
example (x y: Real) (h: x < y):
  Set.Ioi x ∩ Set.Ioi y = Set.Ioi y
  := sorry

end Intervals
