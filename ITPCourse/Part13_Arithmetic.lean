import Mathlib.Data.Real.Basic
import Mathlib.Algebra.Order.GroupWithZero.Unbundled.Basic
import Mathlib.Data.Complex.Basic
import Mathlib.Tactic.Ring
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.FieldSimp

section Basic_arithmetic
/-
  We start with some basic arithmetic formulas manipulations and tactics.

  The main numeric types are:
  - `Complex`, also written as `ℂ`
  - `Real`, also written as `ℝ`
  - `Rat`, also written as `ℚ`
  - `Int`, also written as `ℤ`
  - `Nat`, also written as `ℕ`

  Note that we need the related `import`s for the fancy notation.
-/

example: ℂ := 1 + Complex.I
example: ℝ := 4.6
example: ℚ := 12/17
example: ℤ := -42
example: ℕ := 12

/-
  A basic equation
-/
example: Complex.I^2 = -1
  := Complex.I_sq

/-
  The `ring` tactic can be used to prove those equations that follow by
  commutative ring laws, only.
-/
example (a b: ℝ)
  : (a + b)*(a - b) = a^2 - b^2
  := by ring

/-
  The `ring` tactic will not solve equations that depend on other laws.
  However, we can use `ring_nf` to "simplify" the formula with the ring
  laws, apply some other law, and then try `ring` again.
-/
example: (1 + Complex.I)^2 = 2 * Complex.I
  := by
  ring_nf
  rw [Complex.I_sq]
  ring

/-
  `ring` also applies to semi-rings like `ℕ`.
-/
example (a b: ℕ)
  : (a + b)^2 = a^2 + b^2 + 2*a*b
  := by
  ring

/-
  Linear inequalities can be solved with `linarith`.
  Hypotheses are used as needed.
-/
example (a: ℤ)
  : a < a + 1
  := by
  linarith

example (a b: ℤ)
  (h: a < b)
  : a < b + 1
  := by
  linarith

/-
  Non-linear inequalities can _not_ be solved with `linarith`, in general.
  Sometimes, they can be solved anyway, since the solving process does not
  really involve dealing with the non-linear parts.
-/
example (a b: ℤ)
  : a*b < a*b + 1
  := by
  linarith

/-
  More complex inequalities can require more manual intervention:
-/
example (a b: ℝ)
  : |a+b| < |a|+|b|+1
  := by
  calc |a+b|
  _ ≤ |a| + |b| := abs_add_le _ _
  _ < |a| + |b| + 1 := by linarith

/-
  The `positivity` tactic can solve several goals dealing with positive or
  non-negative quantities.
-/
example
  (x y z: ℝ)
  (h: z > 0)
  : |x| + y^2 + z > 0
  := by
  positivity  -- `linarith` does not suffices here

/-
  Sometimes, two large formulas only differ by a small part.
  The `congr` and `gcongr` tactics can effectively "remove" the common
  parts and focus only on the points the formulas differ.
  They generate a subgoal for each difference.
-/
example (a b c: ℝ)
  (h: a + 6 < b)
  : 1 + c + 5*(c + a + c) ≤ 1 + c + 5*(c + b + c)
  := by
  gcongr
  case bc.h.bc.bc =>
    linarith

/-
  The subgoal names generated by `congr`/`gcongr` can be ugly.
  We can use `.` instead of `case … =>` to avoid mentioning them.
-/
example (a b c: ℝ)
  (h: a + 6 < b)
  : 1 + c + 5*(c + a + c) ≤ 1 + c + 5*(c + b + c)
  := by
  gcongr
  . linarith

/-
  Sometimes, we want to rewrite a part of the formula in an equivalent
  form, so that we can apply a library theorem later on.
  This could be done using `have eq := … ; rw [eq]`, but it is inconvenient.
-/
example (x: ℝ) (P: ℝ → Prop)
  (h1: P (x+x))
  : P (2*x)
  := by
  have eq: 2*x = x+x := by ring
  rw [eq]
  exact h1
/-
  It is simpler to use `convert_to` instead.
-/
example (x: ℝ) (P: ℝ → Prop)
  (h1: P (x+x))
  : P (2*x)
  := by
  convert_to P (x+x)
  . ring   -- Subgoal: prove the equation for the required conversion
  -- We are back to the main statement
  exact h1

/-
  When two expressions are definitionally equal, `change` can be used
  instead of `convert_to`. It does not generate subgoals.

  Note that both `convert_to` and `change` have an `… at h` variant to
  affect an hypothesis instead of the goal.
-/
example
  (P: ℕ → Prop)
  (h1: ∀ x, P (x+0) → P 5)
  (h2: P 7)
  : P 5
  := by
  change P (7+0) at h2
  apply h1 _ h2

/-
  Here's an example of a non-linear inequality on naturals, solved by
  induction.
-/
example (n: Nat)
  : n ≤ n^2
  := by
  induction n
  case zero =>
    rfl
  case succ n ih =>
    ring_nf
    calc 1 + n
    _ ≤ 1 + n^2       := by gcongr
    _ = 1 + 0 + n^2   := by dsimp
    _ ≤ 1 + n*2 + n^2 := by gcongr ; exact Nat.zero_le (n*2)

/-
  The same equality can be solved faster by exploiting the libraries.
-/
example (n: Nat)
  : n ≤ n^2
  := by
  apply Nat.le_self_pow
  linarith

/-
  Some equations on fields can be handled by `field_simp`.
-/
example (x y: ℝ)
  (h: x ≠ 0)
  : x * y / x * x = x * y
  := by
  field_simp

/-
  __Exercise__: Prove the following.
  You will likely only need basic tactics, and `simp` to simplify a few
  sums.
-/
theorem forall_x_y_h
  (P: ℝ → ℝ → Prop)
  : (∀ x y, P x y) ↔ (∀ x h, P x (x+h))
  := sorry

theorem forall_x_y_h_left
  (P: ℝ → ℝ → Prop)
  : (∀ x h, P x (x+h)) → (∀ x y, P x y)
  := (forall_x_y_h P).mpr

/-
  __Exercise__: Prove the following.
  You might want to use:
  - Tactics `linarith`, `let`, `unfold`, `constructor`
  - `lt_or_le`
-/
theorem forall_ε (a b: ℝ)
  : (a ≤ b) ↔ (∀ ε>0, a ≤ b + ε)
  := sorry

end Basic_arithmetic

section On_partial_operations
/-
  Note that some operations on numeric types are partial, i.e. they are
  undefined in some cases. Division by zero is the obvious example.
  Subtraction on naturals can also fail, e.g. `3 - 5`.

  When defining these operations, the library designers had a few options:
  - Require a proof as an additional argument.
    This would require using e.g., `Real.div x y proof_of_y≠0` at each use
    of division.
  - Return an optional result, using some sum type.
    Defining `Real.div: ℝ → ℝ → Option ℝ` allows to return `.none` when the
    second argument is zero, and `.some result` otherwise.
    This would make harder to write `5 + x/y` since `x/y` is an `Option ℝ`,
    and not a `ℝ`.
  - Define division in all cases, in some arbitrary way (say `0`).
    Letting `x/0 = 0` allows one to write formulas more easily, but then
    the user must be careful not to fall into this case.

  The lean designers opted for the last solution:
-/
example: (1: ℝ) / (0: ℝ) = (0: ℝ)    := by ring  -- "Undefined" denoted as 0
example: (3: ℕ) - (5: ℕ) = (0: ℕ)    := by ring  -- "Undefined" denoted as 0
example: (21: ℕ) / (10: ℕ) = (2: ℕ)  := by ring  -- Quotient
/-
  This idea is widespread across the library: the designers opted for
  defining several partial operations in an arbitrary way, so to make them
  total (always defined).

  For instance, when doing calculus, the derivative of the absolute value
  `deriv (λ x => |x|)` is _always_ defined in Lean. More specifically, it is
  `-1` when `x<0`, `0` when `x=0` and `+1` when `x>0`.
  There is another predicate `HasDerivAt …` that states that a function is
  actually differentiable at a point, and that correctly does not hold at
  `0` for the absolute value function.

  Be wary! Properties like
    `(a - b) + b = a`
  fail on `ℕ`, without additional hypotheses. When a tactic unexpected
  fails, it could be because the statement is subtly wrong in some corner
  cases.
-/
end On_partial_operations

section Casts
/-
  It is possible to convert a number to a "larger" numeric type using the
  cast syntax `↑x`, as follows:
-/
example: ℕ → ℤ := λ x => ↑x
example: ℕ → ℚ := λ x => ↑x
example: ℕ → ℝ := λ x => ↑x
example: ℕ → ℂ := λ x => ↑x
example: ℤ → ℚ := λ x => ↑x
example: ℤ → ℝ := λ x => ↑x
example: ℤ → ℂ := λ x => ↑x
example: ℚ → ℝ := λ x => ↑x
example: ℚ → ℂ := λ x => ↑x
example: ℝ → ℂ := λ x => ↑x
/-
  Technically, this involves a few "coercion" type classes.
  We omit the technical details.
  The coercion can often be omitted in several cases.
-/
example: ℕ → ℚ := λ x => x   -- Coercion automatically added.

example (a: ℕ) (b: ℝ)
  : a + b = b + a  -- Coercion automatically added.
  := by ring

/-
  The `push_cast` tactic rewrites `↑(a + b)` as `↑a + ↑b` and similar
  expressions in the analogous way.
-/
example
  (P: ℝ → Prop)
  (h1: ∀ x y: ℝ, P (x + y))
  (a b c: ℕ)
  (h2: c = a + b)
  : P c
  := by
  rw [h2]
  push_cast
  exact h1 ↑a ↑b

/-
  Sometimes, to solve an (in-)equation it is convenient to lift it to a
  larger ring or field.

  For equations, we can do so using the "injectivity of the coercion/cast"
  theorems from the library. These are named
    `Nat.cast_inj`, `Int.cast_inj`, … and so on.
  You might want to specify the new ring/field using `R:=…` or `α:=…`.
-/
example (a b c: ℕ)
  (h: a ≥ b)
  : a - b + c + b = a + c
  := by
  -- We move to integers
  apply (Nat.cast_inj (R:=ℤ)).mp
  -- We push the casts until they are on the variables. Note that we need to
  -- use `h` here, since `↑(a-b)` is not always `↑a - ↑b`. Indeed,
  -- subtraction is a partial operation on ℕ, and `↑(3-4) = 0 ≠ ↑3 - ↑4`.
  push_cast [h]
  ring

/-
  For inequalities, injectivity of the cast does not suffice. We now need to
  rely on "casts preserve `≤`" results. These are named
    `Nat.cast_le`, `Int.cast_le`, … and so on.
-/
example (a b c: ℕ)
  (h: a ≥ b)
  : a - b + c + b ≤ a + c + 1
  := by
  simp at h
  apply (Nat.cast_le (α:=ℤ)).mp
  push_cast [h]
  linarith

/-
  Above, we had to ensure that `a - b` was defined on ℕ by adding the
  hypothesis `a ≥ b`. Similarly, to ensure that `a / b` is defined on ℤ we
  have to assume `b ∣ a` where `∣` is the "divides" relation (`Dvd.dvd`).
-/
example (a b c: ℤ)
  (h1: b ∣ a)
  (h2: b ≠ 0)
  : a / b * c * b = a * c
  := by
  apply (Int.cast_inj (α:=ℚ)).mp
  push_cast [h1]
  field_simp

example (a b c: ℤ)
  (h1: b ∣ a)
  (h2: b ≠ 0)
  : a / b * c * b ≤ a * c + 1
  := by
  apply (Int.cast_le (R:=ℚ)).mp
  push_cast [h1]
  field_simp
  linarith

/-
  __Exercise__: Prove the following.
  Note how `n: ℕ` is automatically converted to a `ℝ` below when we use
  `n * a`. This is done through the `NatCast` type class. If you see `↑n`
  printed instead of `n`, the `↑` is denoting the automatic coercion.
  You might want to use:
  - `⌈ … ⌉₊` aka `Nat.ceil`
  - `Nat.le_ceil`
  - `div_mul_cancel₀`
  - Tactic `push_cast`
  - Tactics `ring`, `congr`, `gcongr`, `positivity`, `simp`, `calc`
-/
theorem archimedes (a b: ℝ)
  (h1: 0 < a)
  (h2: a ≤ b)
  : ∃ n: ℕ, n * a > b
  := sorry

end Casts

section Recap_exercises
/-
  __Exercise__: Prove the following.
  You can exploit any result from the libraries (search for them!).
-/
example
  (x y: ℝ)
  (h: x*y ≥ 0 )
  : x^2 + y^2 ≤ (x+y)^2
  := by
  sorry

/-
  __Exercise__: Prove the following.
  You can exploit any result from the libraries (search for them!). You
  might need to prove some small result before you can exploit the library
  results.
-/
example
  (x: ℝ)
  (h: x > 0 )
  : (x + 1)^2 / x^2 > 1
  := by
  sorry

/-
  __Exercise__: Prove the following, by induction on `n`.
  Watch out for the casts among ℕ,ℤ,ℚ !
-/
example (n: ℕ)
  : ∃ x: ℤ, ((n+1) * n / (2: ℚ)) = x
  := by
  sorry

/-
  __Exercise__: Prove the following non-linear systen.
  You can exploit any result from the libraries (search for them!).
  You might need `ne_of_lt`.
-/
example
  (a₀ a₁ b₀ b₁ p₀ p₁: ℝ)
  (pos_a₀: 0 < a₀) (pos_b₀: 0 < b₀)
  (pos_p₀: 0 < p₀) (pos_p₁: 0 < p₁)
  (hp: a₀ * a₁ = b₀ * b₁)
  (ha: a₀ * p₀ = a₁ * p₁)
  (hb: b₀ * p₀ = b₁ * p₁)
  : a₀ = b₀ ∧ a₁ = b₁
  := by
  sorry

/-
  __Exercise__: Consider the following two definitions of even natural
  number. Prove they are equivalent.
  You can use `constructor`, `induction` (on two types), `exists`, `have`,
  and a few other tactics.
-/
def even₁ (n: ℕ): Prop := ∃ k: ℕ, n = 2*k

inductive even₂: ℕ → Prop
| zero: even₂ 0
| next: ∀ n, even₂ n → even₂ (n+2)

theorem even₁_iff_even₂ (n: ℕ)
  : even₁ n ↔ even₂ n
  := by
  sorry

end Recap_exercises
